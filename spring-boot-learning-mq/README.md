# 消息中间件

## 为什么需要消息中间件？

- 解耦：因为消息其实是语言和平台无关的数据，而且在语义上，也不是基于函数的调用，因此消息队列也可以实现多个应用之间松耦合的交互。
  如今很多系统都是采用微服务分布式架构，经常会有跨应用之间的远程调用，如果服务A和服务B分别在两个应用中，在不使用MQ的情况下，A调用B是强耦合的，如果B服务宕机了，那么就会
  导致A服务也会处于不可用的状态，如果引入了MQ进行解耦，那么A只需要将消息正常投递到MQ中，整个流程就算成功了，即使B服务当前处于不可用，也不会影响A服务的正常运行。
  
- 异步：消息队列的主要特点是异步的，主要的目的就是为了减少请求阻塞等待的消耗，所以主要的使用场景就是将那些比较耗时并且不是必须同步返回结果的操作（如磁盘IO，发邮件，短信）放入到队列中。
  
- 削峰：在某些场景中，由于在短时间会产生大量的请求，如果都是采用同步阻塞的方式处理请求，那么会产生大量的请求积压，最终会降低计算机的性能，而通过消息队列
将大量的请求处理放置在队列中，让请求的处理变得更平缓一些，让消费者有足够的时间去消费消息。

### JMS中的一些角色

### Broker
消息服务器，作为server提供消息核心服务。

### Destination
Destination 目的地，是由消息生产者将消息发送到何处以及消费者消费消息的来源。

#### Queue
Queue 称为 队列，是基于点对点的P2P模式，有以下特点：
  - 点对点的，消息被消费之后就会消失，所以不会出现重复消费
  - 支持多个Consumer，但是对于一个Message而言，只会被一个Consumer消费。如果消费者没有消费，消息会一直在队列中等待消费。

#### Topic 
Topic 是基于 Pub/Sub 发布订阅的模式：
  - 支持多个订阅者订阅，当消息发布到Topic中后，所有的订阅者都会受到消息
  - 如果消息发布到Topic中，但是没有消费者，此时会丢失Topic
  - 消费者要先进行订阅，才能接收到消息

### Provider
生产者，消息生产者是由会话创建的一个对象，用于把消息发送到一个目的地（Queue/Topic）。

### Consumer
消费者，消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。

消息的消费可以采用以下两种方法之一：
- 同步消费。通过调用消费者的receive方法从目的地中显式提取消息。receive方法可以一直阻塞到消息到达。
- 异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。

### Message
Message是在JMS标准中的数据载体，即我们需要发送的消息都需要封装成该对象，目前常见的消息类型主要有以下几种：
- `TextMessage`：传输的是文本类型的消息。
- `MapMessage`：传输基于 `key - value` 键值对的消息。
- `ObjectMessage`：传输可序列化的对象数据。
- `ByteMessage`：传递字节类型的，如文件。
- `StreamMessage`

消息中除了我们需要传送的数据外，还包含了一些其他关键的信息：
- 消息头
    * JMSMessageID：消息的唯一标识
    * JMSCorrelationID：可以用作类似于消息会话的ID
    * ReplyTo：消息接收后的应答 Destination
    * JMSDeliveryMode：消息是否持久化
    * JMSPriority：消息的优先级，高优先级的消息会优先被消费
    * JMSExpiration：消息的过期时间，如：消息过期后会进入到死信队列。
    * .....
    
- 消息额外属性（Property）
  消息的额外属性可用作消费者在消费消息是利用selector去过滤消费指定的规则。
  
- 消息体，即需要真实发送的业务数据。
  
## ActiveMQ

[Active MQ](src\main\java\com\leofee\activemq)

## RocketMQ

[Rocket MQ](src\main\java\com\leofee\rocketmq)
